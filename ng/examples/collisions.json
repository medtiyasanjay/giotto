{"image": "http://giottojs.org/examples/collisions.png", "description": "A list of GiottoJS examples", "api_url": "http://giottojs.org/ng/examples/collisions.json", "head": {"description": "A list of GiottoJS examples", "title": "Collision Detection", "twitter:card": "summary_large_image"}, "slug": "collisions", "name": "collisions", "robots": ["noindex", "nofollow"], "html": {"main": "<div id=\"page-main\">\n<div class=\"container\">\n<div class=\"row\">\n<div class=\"col-sm-12\" data-highlight>\n<div class=\"page-header\">\n<h2>Collision Detection</h2>\n</div>\n<div class=\"container-fluid\">\n  <div class=\"row\">\n    <div class=\"col-sm-10\">\n      <div data-options=\"gexamples.force1\" style=\"width: 100%;\" giotto-viz></div>\n    </div>\n    <div class=\"col-sm-2 small\">\n     <div data-jstats></div>\n      <lux-form data-options='luxforms.collision_cuhrI'><script>if (!this.luxforms) {this.luxforms = {};} this.luxforms.collision_cuhrI = {\"field\": {\"model\": \"Collision\", \"type\": \"form\", \"id\": \"collision_cuhrI\"}, \"children\": [{\"field\": {\"type\": \"fieldset\"}, \"children\": [{\"field\": {\"name\": \"type\", \"value\": \"svg\", \"type\": \"select\", \"options\": [\"svg\", \"canvas\"], \"required\": true}}, {\"field\": {\"min\": 0, \"max\": 1, \"type\": \"number\", \"required\": true, \"name\": \"gravity\", \"value\": 0.05}}, {\"field\": {\"name\": \"charge\", \"value\": -0.02, \"type\": \"number\", \"required\": true}}, {\"field\": {\"min\": 0, \"max\": 1, \"type\": \"number\", \"required\": true, \"name\": \"friction\", \"value\": 0.9}}]}]};</script></lux-form>\n    </div>\n  </div>\n</div>\n<h3>Javascript code</h3>\n<pre><code>gexamples.force1 = {\n    margin: 0,\n    nodes: 150,\n    minRadius: 0.005,\n    maxRadius: 0.02,\n    gravity: 0.05,\n    charge: -0.02,\n\n    height: '60%',\n\n    point: {\n        color: '#555',\n        width: 1,\n        fillOpacity: 1\n    },\n\n    onInit: function (viz, opts) {\n\n        var root = {fixed: true, size: 0, x: -1, y: -1},\n            force = d3.layout.force(),\n            nodes = d3.range(+opts.nodes).map(function() {\n                var minRadius = +opts.minRadius,\n                    maxRadius = +opts.maxRadius,\n                    dr = maxRadius &gt; minRadius ? maxRadius - minRadius : 0;\n                return {\n                    size: Math.random() * dr + minRadius,\n                    x: Math.random(),\n                    y: Math.random()\n                };\n            }),\n            group;\n\n        // Add the dummy node for the mouse\n        //nodes.push({fixed: true, size: 0, x: -1, y: -1});\n\n        force.nodes(nodes).charge(opts._charge(opts.charge));\n\n        viz.force = force;\n\n        function init () {\n            group = viz.paper(true).group();\n\n            // rescale\n            group.add(function () {\n                group.yaxis().scale().domain([0, group.aspectRatio()]);\n                force.size([1, group.aspectRatio()]);\n            });\n            group.points(force.nodes())\n                    .size(function (d) {\n                        return group.scale(d.size);\n                    })\n                    .x(function (d) {return d.x;})\n                    .y(function (d) {return d.y;});\n\n            viz.paper().on(\"mousemove.collide\", function() {\n                var p1 = d3.mouse(this);\n                root.x = group.xfromPX(p1[0]);\n                root.y = group.yfromPX(p1[1]);\n                force.resume();\n            }).on(\"touchmove.collide\", function() {\n                var p1 = d3.touches(this);\n                root.x = group.xfromPX(p1[0][0]);\n                root.y = group.yfromPX(p1[0][1]);\n                force.resume();\n            });\n        }\n\n        force.on(\"tick.collide\", function(e) {\n            if (!group || opts.type !== group.type()) init();\n            //collide(group, force);\n            group.render();\n        });\n\n        force.start();\n    },\n\n    _charge: function (charge) {\n        return function (d) {\n            return charge; //d.fixed ? opts.charge : 0;\n        };\n    },\n\n    // Callback when angular directive\n    angular: function (viz, opts) {\n\n        opts.scope.$on('formFieldChange', function (e, model, field) {\n            var force = viz.force;\n\n            if (field === 'friction' &amp;&amp; model.friction)\n                force.friction(model.friction);\n            else if (field === 'gravity')\n                force.gravity(model.gravity);\n            else if (field === 'charge')\n                force.charge(opts._charge(model.charge)).start();\n            else if (field === 'type')\n                opts.type = model.type;\n\n            force.resume();\n        });\n\n    }\n};\n\nfunction collide (group, force) {\n    var collidePadding = 0.002,\n        collideBuffer = 0.02,\n        nodes = force.nodes(),\n        scalex = group.xaxis().scale(),\n        scaley = group.yaxis().scale(),\n        buffer = scalex(collideBuffer),\n        padding = scalex(collidePadding),\n        q = d3.geom.quadtree(nodes),\n        node;\n\n        for (var i=0; i&lt;nodes.length; ++i)\n            q.visit(circleCollide(nodes[i], buffer));\n\n    function circleCollide (node, buffer) {\n\n        var r = node.size + buffer,\n            nx1 = node.x - r,\n            nx2 = node.x + r,\n            ny1 = node.y - r,\n            ny2 = node.y + r,\n            dx, dy, d;\n\n        return function(quad, x1, y1, x2, y2) {\n            if (quad.point &amp;&amp; (quad.point !== node)) {\n                dx = node.x - quad.point.x;\n                dy = node.y - quad.point.y;\n                d = Math.sqrt(dx * dx + dy * dy);\n                r = node.size + quad.point.size;\n                if (d &lt; r) {\n                    d = 0.5 * (r - d) / d;\n                    dx *= d;\n                    dy *= d;\n                    if (node.fixed || quad.point.fixed) {\n                        if (node.fixed) {\n                            quad.point.x -= 2*dx;\n                            quad.point.y -= 2*dy;\n                        } else {\n                            node.x += 2*dx;\n                            node.y += 2*dy;\n                        }\n                    } else {\n                        node.x += dx;\n                        node.y += dy;\n                        quad.point.x -= dx;\n                        quad.point.y -= dy;\n                    }\n                }\n            }\n            return x1 &gt; nx2 || x2 &lt; nx1 || y1 &gt; ny2 || y2 &lt; ny1;\n        };\n    }\n\n}\n</code></pre>\n</div>\n</div>\n</div>\n</div>\n<script>\n\n    gexamples.force1 = {\n        margin: 0,\n        nodes: 150,\n        minRadius: 0.005,\n        maxRadius: 0.02,\n        gravity: 0.05,\n        charge: -0.02,\n\n        height: '60%',\n\n        point: {\n            color: '#555',\n            width: 1,\n            fillOpacity: 1\n        },\n\n        onInit: function (viz, opts) {\n\n            var root = {fixed: true, size: 0, x: -1, y: -1},\n                force = d3.layout.force(),\n                nodes = d3.range(+opts.nodes).map(function() {\n                    var minRadius = +opts.minRadius,\n                        maxRadius = +opts.maxRadius,\n                        dr = maxRadius > minRadius ? maxRadius - minRadius : 0;\n                    return {\n                        size: Math.random() * dr + minRadius,\n                        x: Math.random(),\n                        y: Math.random()\n                    };\n                }),\n                group;\n\n            // Add the dummy node for the mouse\n            //nodes.push({fixed: true, size: 0, x: -1, y: -1});\n\n            force.nodes(nodes).charge(opts._charge(opts.charge));\n\n            viz.force = force;\n\n            function init () {\n                group = viz.paper(true).group();\n\n                // rescale\n                group.add(function () {\n                    group.yaxis().scale().domain([0, group.aspectRatio()]);\n                    force.size([1, group.aspectRatio()]);\n                });\n                group.points(force.nodes())\n                        .size(function (d) {\n                            return group.scale(d.size);\n                        })\n                        .x(function (d) {return d.x;})\n                        .y(function (d) {return d.y;});\n\n                viz.paper().on(\"mousemove.collide\", function() {\n                    var p1 = d3.mouse(this);\n                    root.x = group.xfromPX(p1[0]);\n                    root.y = group.yfromPX(p1[1]);\n                    force.resume();\n                }).on(\"touchmove.collide\", function() {\n                    var p1 = d3.touches(this);\n                    root.x = group.xfromPX(p1[0][0]);\n                    root.y = group.yfromPX(p1[0][1]);\n                    force.resume();\n                });\n            }\n\n            force.on(\"tick.collide\", function(e) {\n                if (!group || opts.type !== group.type()) init();\n                //collide(group, force);\n                group.render();\n            });\n\n            force.start();\n        },\n\n        _charge: function (charge) {\n            return function (d) {\n                return charge; //d.fixed ? opts.charge : 0;\n            };\n        },\n\n        // Callback when angular directive\n        angular: function (viz, opts) {\n\n            opts.scope.$on('formFieldChange', function (e, model, field) {\n                var force = viz.force;\n\n                if (field === 'friction' && model.friction)\n                    force.friction(model.friction);\n                else if (field === 'gravity')\n                    force.gravity(model.gravity);\n                else if (field === 'charge')\n                    force.charge(opts._charge(model.charge)).start();\n                else if (field === 'type')\n                    opts.type = model.type;\n\n                force.resume();\n            });\n\n        }\n    };\n\n    function collide (group, force) {\n        var collidePadding = 0.002,\n            collideBuffer = 0.02,\n            nodes = force.nodes(),\n            scalex = group.xaxis().scale(),\n            scaley = group.yaxis().scale(),\n            buffer = scalex(collideBuffer),\n            padding = scalex(collidePadding),\n            q = d3.geom.quadtree(nodes),\n            node;\n\n            for (var i=0; i<nodes.length; ++i)\n                q.visit(circleCollide(nodes[i], buffer));\n\n        function circleCollide (node, buffer) {\n\n            var r = node.size + buffer,\n                nx1 = node.x - r,\n                nx2 = node.x + r,\n                ny1 = node.y - r,\n                ny2 = node.y + r,\n                dx, dy, d;\n\n            return function(quad, x1, y1, x2, y2) {\n                if (quad.point && (quad.point !== node)) {\n                    dx = node.x - quad.point.x;\n                    dy = node.y - quad.point.y;\n                    d = Math.sqrt(dx * dx + dy * dy);\n                    r = node.size + quad.point.size;\n                    if (d < r) {\n                        d = 0.5 * (r - d) / d;\n                        dx *= d;\n                        dy *= d;\n                        if (node.fixed || quad.point.fixed) {\n                            if (node.fixed) {\n                                quad.point.x -= 2*dx;\n                                quad.point.y -= 2*dy;\n                            } else {\n                                node.x += 2*dx;\n                                node.y += 2*dy;\n                            }\n                        } else {\n                            node.x += dx;\n                            node.y += dy;\n                            quad.point.x -= dx;\n                            quad.point.y -= dy;\n                        }\n                    }\n                }\n                return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;\n            };\n        }\n\n    }\n\n</script>\n<div id=\"footer\">\n<div class=\"container\">\n<div class=\"row\">\n<div class=\"col-sm-12 small\">\n<p>Library released under the <a href=\"http://opensource.org/licenses/BSD-3-Clause\">BSD License</a>.</p>\n<p>Copyright 2015 <a href=\"http://lucasbardella.com\">Luca Sbardella</a> and <a href=\"http://quantmind.com\">Quantmind</a></p>\n</div>\n</div>\n</div>\n</div>\n"}, "modified": "2015-01-11T10:01:33", "html_url": "http://giottojs.org/examples/collisions", "title": "Collision Detection", "content_type": "text/html", "priority": "0", "site": {"media": "/media", "python_version": "3.4.2", "date": "2015-01-15T11-04-25", "lux_version": "0.1.2-alpha.1", "name": "Lux", "template_engine": null, "template": "partials/examples.html", "year": 2015, "url": "http://giottojs.org"}}